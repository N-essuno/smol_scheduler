# Simulation Model
The SMOL simulation model consists of three parts. Details of SMOL itself are described at [its webpage](https://smolang.org). 
 * The `AssetModel` class in `GreenHouse.smol` is the entry point for the program and used for communication with the simulation driver
It contains the list of control decisions, the controller that makes these decisions, and a list of kind models, which are
used for configuration adaptation. The assets, plants, pots, etc., are no explicitly managed and must be retrieved using semantic lifting.
The method `decision` is used for control, the method `reconfigure` for adaptation.

 * The `AssetController` class in `Greenhouse_ctrl.smol` is responsible for control. It has a reference to the asset model, 
as well as a `DecisionMaker` instance. This instance is making the actual decision based on the current and ideal value and encapsulates possible
decision strategies: `DirectControl` uses a simple threshold, while `ModelControl` uses model-based control (see below).
In the demo, we only control pumps.

 * The `KindModel` class in `GreenHouse.smol` provides the interface for different kinds of assets that must be managed.
Each of the files `Greenhouse_health.smol`, `Greenhouse_plants.smol`, `Greenhouse_pots.smol`, `Greenhouse_pumps.smol` contains one subclass.
Every subclass must implement a defect query to detect new instances of the asset it twins, a defect query to detect superfluous instances,
and a defect query for every property that can change.

 * All auxiliary classes are in `Greenhouse_data.smol`. 
# Extensions
## General Extensions
 * To extend the greenhouse with a new kind of asset, one must (a) add a new class that twins such assets,
(b) extend the asset model in `greenhouse.ttl` with an OWL class for this asset, together with the corresponding properties,
(c) add a subclass of `KindModel` with the corresponding defect queries, and 
(d) instantiate this class and register it with the `AssetModel` instance created in the main block.

 * To add or change the way control decisions are made, one must modify `AssetController`. This should be split into the decision itself
as a subclass of `DecisionMaker` and an extension of the `AssetController.decision` method.

 * To add a new interface to communicate with the simulation driver, one must extend `AssetModel`.
To receive calls, implement a new method, to return information, add a new field that will be filled by the corresponding method.

## Examples
The following describes the two extensions introduced in the accompanying article.
### Health Monitoring
Health monitoring adds a report capability to the system. 
The asset model stores a set of health status that define an upper and limit on the NDVI of the plant.
At every adaptation cycle, the plant also determines which health status is currently has.

Changes in the SMOL code are annotated with `//NDVI` and include the following
* Health status are handled as a kind of asset that can be added, removed and modified. Cf. the `KindModel` in file `Greenhouse_health.smol` and its registration in `GreenHouse.smol`.
* Plants must determine their status. Cf. the modification in `Greenhouse_plants.smol`  

Additionally, the ontology has to be extended. This requires to add the class `HealthState` and the properties `hasHealthState`, `maxNdvi`, and `minNdvi` in `greenhouse.ttl`.



### Model-Based Control
Model-based control adds the capability to make decision based on a continuous model of the expected behavior.
The model is compared with the sensor stream and reconfigured if model and sensor drift apart too far.

The model is given as modelica code in `MBC.mo` and the exported FMU is in `MBC.fmu`. The FMU works only on an x86 Linux machine,
but a new FMU can be generated by the OpenModelica export function from the modelica code.


Changes in the SMOL code are annotated with `//MBC` and are in the file `Greenhouse_ctrl.smol`